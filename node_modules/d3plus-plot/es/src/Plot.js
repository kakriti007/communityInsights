function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/* eslint no-cond-assign: 0 */
import { deviation, extent, max, mean, merge, min, range, sum } from "d3-array";
import { nest } from "d3-collection";
import * as scales from "d3-scale";
import * as d3Shape from "d3-shape";
import { AxisBottom, AxisLeft, AxisRight, AxisTop, date } from "d3plus-axis";
import { colorAssign, colorLegible } from "d3plus-color";
import { accessor, assign, configPrep, constant, elem } from "d3plus-common";
import * as shapes from "d3plus-shape";
import { textWidth, TextBox } from "d3plus-text";
var testLineShape = new shapes.Line();
var testTextBox = new TextBox();
import { Viz } from "d3plus-viz";
import { default as BarBuffer } from "./buffers/Bar.js";
import { default as BoxBuffer } from "./buffers/Box.js";
import { default as CircleBuffer } from "./buffers/Circle.js";
import { default as LineBuffer } from "./buffers/Line.js";
import { default as RectBuffer } from "./buffers/Rect.js";
/**
    @desc Logic for determining default sizes of shapes using the sizeScaleD3 internal function.
    @private
*/

function defaultSize(d) {
  return this._sizeScaleD3(this._size ? this._size(d) : null);
}
/**
    @desc Logic for determining stackOrder ascending using groups.
    @private
*/


function stackOrderAscending(series) {
  var sums = series.map(stackSum);
  var keys = series.map(function (d) {
    return d.key.split("_")[0];
  });
  return d3Shape.stackOrderNone(series).sort(function (a, b) {
    return keys[b].localeCompare(keys[a]) || sums[a] - sums[b];
  });
}
/**
    @desc Logic for determining stackOrder descending using groups.
    @private
*/


function stackOrderDescending(series) {
  return stackOrderAscending(series).reverse();
}
/**
    @desc Logic for determining default sum of shapes using the stackSum function used in d3Shape.
    @private
*/


function stackSum(series) {
  var i = -1,
      s = 0,
      v;
  var n = series.length;

  while (++i < n) {
    if (v = +series[i][1]) s += v;
  }

  return s;
}
/**
    @desc Logic for determining default sum of shapes using the stackSum function used in d3Shape.
    @private
*/


function stackOffsetDiverging(series, order) {
  var n;
  if (!((n = series.length) > 0)) return;
  var d, dy, i, yn, yp;
  var m = series[order[0]].length;

  for (var j = 0; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
}
/**
    @class Plot
    @extends Viz
    @desc Creates an x/y plot based on an array of data.
*/


var Plot =
/*#__PURE__*/
function (_Viz) {
  _inherits(Plot, _Viz);

  /**
      @memberof Plot
      @desc Invoked when creating a new class instance, and sets any default parameters.
      @private
  */
  function Plot() {
    var _this;

    _classCallCheck(this, Plot);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Plot).call(this));
    _this._annotations = [];
    _this._backgroundConfig = {
      duration: 0,
      fill: "transparent"
    };
    _this._barPadding = 0;
    _this._buffer = {
      Bar: BarBuffer,
      Box: BoxBuffer,
      Circle: CircleBuffer,
      Line: LineBuffer,
      Rect: RectBuffer
    };
    _this._confidenceConfig = {
      fillOpacity: constant(0.5)
    };
    _this._discreteCutoff = 100;
    _this._groupPadding = 5;
    _this._lineMarkerConfig = {
      fill: function fill(d, i) {
        return colorAssign(_this._id(d, i));
      },
      r: constant(3)
    };
    _this._lineMarkers = false;
    _this._previousShapes = [];
    _this._shape = constant("Circle");
    _this._shapeConfig = assign(_this._shapeConfig, {
      Area: {
        label: function label(d, i) {
          return _this._stacked ? _this._drawLabel(d, i) : false;
        },
        labelConfig: {
          fontResize: true
        }
      },
      ariaLabel: function ariaLabel(d, i) {
        var ariaLabelStr = "";
        if (d.nested) ariaLabelStr = "".concat(_this._drawLabel(d.data, d.i));else {
          ariaLabelStr = "".concat(_this._drawLabel(d, i));
          if (_this._x(d, i) !== undefined) ariaLabelStr += ", x: ".concat(_this._x(d, i));
          if (_this._y(d, i) !== undefined) ariaLabelStr += ", y: ".concat(_this._y(d, i));
          if (_this._x2(d, i) !== undefined) ariaLabelStr += ", x2: ".concat(_this._x2(d, i));
          if (_this._y2(d, i) !== undefined) ariaLabelStr += ", y2: ".concat(_this._y2(d, i));
        }
        return "".concat(ariaLabelStr, ".");
      },
      Bar: {
        labelConfig: {
          textAnchor: function textAnchor() {
            return _this._discrete === "x" ? "middle" : "end";
          },
          verticalAlign: function verticalAlign() {
            return _this._discrete === "x" ? "top" : "middle";
          }
        }
      },
      Circle: {
        r: defaultSize.bind(_assertThisInitialized(_this))
      },
      Line: {
        fill: constant("none"),
        labelConfig: {
          fontColor: function fontColor(d, i) {
            return colorLegible(colorAssign(_this._id(d, i)));
          },
          fontResize: false,
          padding: 5,
          textAnchor: "start",
          verticalAlign: "middle"
        },
        stroke: function stroke(d, i) {
          return colorAssign(_this._id(d, i));
        },
        strokeWidth: constant(2)
      },
      Rect: {
        height: function height(d) {
          return defaultSize.bind(_assertThisInitialized(_this))(d) * 2;
        },
        width: function width(d) {
          return defaultSize.bind(_assertThisInitialized(_this))(d) * 2;
        }
      }
    });
    _this._shapeOrder = ["Area", "Path", "Bar", "Box", "Line", "Rect", "Circle"];

    _this._shapeSort = function (a, b) {
      return _this._shapeOrder.indexOf(a) - _this._shapeOrder.indexOf(b);
    };

    _this._sizeMax = 20;
    _this._sizeMin = 5;
    _this._sizeScale = "sqrt";
    _this._stackOffset = stackOffsetDiverging;
    _this._stackOrder = stackOrderDescending;
    _this._timelineConfig = assign(_this._timelineConfig, {
      brushing: true
    });
    _this._x = accessor("x");
    _this._xAxis = new AxisBottom().align("end");
    _this._xTest = new AxisBottom().align("end").gridSize(0);
    _this._xConfig = {};
    _this._xCutoff = 150;
    _this._x2 = accessor("x2");
    _this._x2Axis = new AxisTop().align("start");
    _this._x2Test = new AxisTop().align("start").gridSize(0);
    _this._x2Config = {
      padding: 0
    };
    _this._y = accessor("y");
    _this._yAxis = new AxisLeft().align("start");
    _this._yTest = new AxisLeft().align("start").gridSize(0);
    _this._yConfig = {
      gridConfig: {
        stroke: function stroke(d) {
          var range = _this._yAxis.range(); // hides bottom-most y gridline so it doesn't overlap with the x axis


          return range[range.length - 1] === _this._yAxis._getPosition.bind(_this._yAxis)(d.id) ? "transparent" : "#ccc";
        }
      }
    };
    _this._yCutoff = 150;
    _this._y2 = accessor("y2");
    _this._y2Axis = new AxisRight().align("end");
    _this._y2Test = new AxisLeft().align("end").gridSize(0);
    _this._y2Config = {};
    return _this;
  }
  /**
      Extends the draw behavior of the abstract Viz class.
      @private
  */


  _createClass(Plot, [{
    key: "_draw",
    value: function _draw(callback) {
      var _this2 = this;

      if (!this._filteredData.length) return this;

      var stackGroup = function stackGroup(d, i) {
        return _this2._stacked ? "".concat(_this2._groupBy.length > 1 ? _this2._ids(d, i).slice(0, -1).join("_") : "group") : "".concat(_this2._ids(d, i).join("_"));
      };

      var data = this._filteredData.map(function (d, i) {
        return {
          __d3plus__: true,
          data: d,
          group: stackGroup(d, i),
          i: i,
          hci: _this2._confidence && _this2._confidence[1] && _this2._confidence[1](d, i),
          id: _this2._ids(d, i).slice(0, _this2._drawDepth + 1).join("_"),
          lci: _this2._confidence && _this2._confidence[0] && _this2._confidence[0](d, i),
          shape: _this2._shape(d, i),
          x: _this2._x(d, i),
          x2: _this2._x2(d, i),
          y: _this2._y(d, i),
          y2: _this2._y2(d, i)
        };
      });

      this._formattedData = data;

      if (this._size) {
        var rExtent = extent(data, function (d) {
          return _this2._size(d.data);
        });

        this._sizeScaleD3 = function () {
          return _this2._sizeMin;
        };

        this._sizeScaleD3 = scales["scale".concat(this._sizeScale.charAt(0).toUpperCase()).concat(this._sizeScale.slice(1))]().domain(rExtent).range([rExtent[0] === rExtent[1] ? this._sizeMax : min([this._sizeMax / 2, this._sizeMin]), this._sizeMax]);
      } else {
        this._sizeScaleD3 = function () {
          return _this2._sizeMin;
        };
      }

      var x2Exists = data.some(function (d) {
        return d.x2 !== undefined;
      }),
          y2Exists = data.some(function (d) {
        return d.y2 !== undefined;
      });
      var height = this._height - this._margin.top - this._margin.bottom,
          opp = this._discrete ? this._discrete === "x" ? "y" : "x" : undefined,
          opp2 = this._discrete ? this._discrete === "x" ? "y2" : "x2" : undefined,
          opps = [opp, opp2].filter(function (d) {
        return d;
      }),
          parent = this._select,
          transition = this._transition,
          width = this._width - this._margin.left - this._margin.right;

      var x2Time = this._time && data[0].x2 === this._time(data[0].data, data[0].i),
          xTime = this._time && data[0].x === this._time(data[0].data, data[0].i),
          y2Time = this._time && data[0].y2 === this._time(data[0].data, data[0].i),
          yTime = this._time && data[0].y === this._time(data[0].data, data[0].i);

      for (var i = 0; i < data.length; i++) {
        var d = data[i];
        if (xTime) d.x = date(d.x);
        if (x2Time) d.x2 = date(d.x2);
        if (yTime) d.y = date(d.y);
        if (y2Time) d.y2 = date(d.y2);
        d.discrete = d.shape === "Bar" ? "".concat(d[this._discrete], "_").concat(d.group) : "".concat(d[this._discrete]);
      }

      var discreteKeys, domains, stackData, stackKeys;

      if (this._stacked) {
        var _domains;

        var groupValues = nest().key(function (d) {
          return d.group;
        }).entries(data).reduce(function (obj, d) {
          if (!obj[d.key]) obj[d.key] = 0;
          obj[d.key] += sum(d.values, function (dd) {
            return dd[opp];
          });
          return obj;
        }, {});
        data = data.sort(function (a, b) {
          if (_this2["_".concat(_this2._discrete, "Sort")]) return _this2["_".concat(_this2._discrete, "Sort")](a.data, b.data);
          var a1 = a[_this2._discrete],
              b1 = b[_this2._discrete];
          if (a1 - b1 !== 0) return a1 - b1;
          if (a.group !== b.group) return groupValues[b.group] - groupValues[a.group];
          return b[opp] - a[opp];
        });
        discreteKeys = Array.from(new Set(data.map(function (d) {
          return d.discrete;
        })));
        stackKeys = Array.from(new Set(data.map(function (d) {
          return d.id;
        })));
        stackData = nest().key(function (d) {
          return d.discrete;
        }).entries(data).map(function (d) {
          return d.values;
        });
        stackData.forEach(function (g) {
          var ids = Array.from(new Set(g.map(function (d) {
            return d.id;
          })));

          if (ids.length < stackKeys.length) {
            stackKeys.forEach(function (k) {
              if (!ids.includes(k)) {
                var _d = data.filter(function (d) {
                  return d.id === k;
                })[0];

                if (_d.shape === "Area") {
                  var _fillerPoint;

                  var group = stackGroup(_d.data, _d.i);
                  var fillerPoint = (_fillerPoint = {
                    __d3plus__: true,
                    data: _d.data,
                    discrete: _d.shape === "Bar" ? "".concat(g[0][_this2._discrete], "_").concat(group) : "".concat(g[0][_this2._discrete]),
                    group: group,
                    id: k,
                    shape: _d.shape
                  }, _defineProperty(_fillerPoint, _this2._discrete, g[0][_this2._discrete]), _defineProperty(_fillerPoint, opp, 0), _fillerPoint);
                  data.push(fillerPoint);
                }
              }
            });
          }
        });

        if (this["_".concat(this._discrete, "Sort")]) {
          data.sort(function (a, b) {
            return _this2["_".concat(_this2._discrete, "Sort")](a.data, b.data);
          });
        } else {
          data.sort(function (a, b) {
            return a[_this2._discrete] - b[_this2._discrete];
          });
        }

        var order = this._stackOrder;
        if (order instanceof Array) stackKeys.sort(function (a, b) {
          return order.indexOf(a) - order.indexOf(b);
        });else if (order === d3Shape.stackOrderNone) stackKeys.sort(function (a, b) {
          return a.localeCompare(b);
        });
        stackData = d3Shape.stack().keys(stackKeys).offset(this._stackOffset).order(order instanceof Array ? d3Shape.stackOrderNone : order).value(function (group, key) {
          var d = group.filter(function (g) {
            return g.id === key;
          });
          return d.length ? d[0][opp] : 0;
        })(stackData);
        domains = (_domains = {}, _defineProperty(_domains, this._discrete, extent(data, function (d) {
          return d[_this2._discrete];
        })), _defineProperty(_domains, opp, [min(stackData.map(function (g) {
          return min(g.map(function (p) {
            return p[0];
          }));
        })), max(stackData.map(function (g) {
          return max(g.map(function (p) {
            return p[1];
          }));
        }))]), _domains);
      } else {
        var _discrete = this._discrete || "x";

        if (this["_".concat(this._discrete, "Sort")]) {
          data.sort(function (a, b) {
            return _this2["_".concat(_this2._discrete, "Sort")](a.data, b.data);
          });
        } else {
          data.sort(function (a, b) {
            return a[_discrete] - b[_discrete];
          });
        }

        var xData = _discrete === "x" ? data.map(function (d) {
          return d.x;
        }) : data.map(function (d) {
          return d.x;
        }).concat(this._confidence && this._confidence[0] ? data.map(function (d) {
          return d.lci;
        }) : []).concat(this._confidence && this._confidence[1] ? data.map(function (d) {
          return d.hci;
        }) : []);
        var x2Data = _discrete === "x" ? data.map(function (d) {
          return d.x2;
        }) : data.map(function (d) {
          return d.x2;
        }).concat(this._confidence && this._confidence[0] ? data.map(function (d) {
          return d.lci;
        }) : []).concat(this._confidence && this._confidence[1] ? data.map(function (d) {
          return d.hci;
        }) : []);
        var yData = _discrete === "y" ? data.map(function (d) {
          return d.y;
        }) : data.map(function (d) {
          return d.y;
        }).concat(this._confidence && this._confidence[0] ? data.map(function (d) {
          return d.lci;
        }) : []).concat(this._confidence && this._confidence[1] ? data.map(function (d) {
          return d.hci;
        }) : []);
        var y2Data = _discrete === "y" ? data.map(function (d) {
          return d.y2;
        }) : data.map(function (d) {
          return d.y2;
        }).concat(this._confidence && this._confidence[0] ? data.map(function (d) {
          return d.lci;
        }) : []).concat(this._confidence && this._confidence[1] ? data.map(function (d) {
          return d.hci;
        }) : []);
        domains = {
          x: this._xSort ? Array.from(new Set(data.filter(function (d) {
            return d.x;
          }).sort(function (a, b) {
            return _this2._xSort(a.data, b.data);
          }).map(function (d) {
            return d.x;
          }))) : extent(xData, function (d) {
            return d;
          }),
          x2: this._x2Sort ? Array.from(new Set(data.filter(function (d) {
            return d.x2;
          }).sort(function (a, b) {
            return _this2._x2Sort(a.data, b.data);
          }).map(function (d) {
            return d.x2;
          }))) : extent(x2Data, function (d) {
            return d;
          }),
          y: this._ySort ? Array.from(new Set(data.filter(function (d) {
            return d.y;
          }).sort(function (a, b) {
            return _this2._ySort(a.data, b.data);
          }).map(function (d) {
            return d.y;
          }))) : extent(yData, function (d) {
            return d;
          }),
          y2: this._y2Sort ? Array.from(new Set(data.filter(function (d) {
            return d.y2;
          }).sort(function (a, b) {
            return _this2._y2Sort(a.data, b.data);
          }).map(function (d) {
            return d.y2;
          }))) : extent(y2Data, function (d) {
            return d;
          })
        };
      }

      var xDomain = this._xDomain ? this._xDomain.slice() : domains.x,
          xScale = this._xSort ? "Point" : "Linear";
      if (xDomain[0] === void 0) xDomain[0] = domains.x[0];
      if (xDomain[1] === void 0) xDomain[1] = domains.x[1];

      if (xTime) {
        xDomain = xDomain.map(date);
        xScale = "Time";
      } else if (this._discrete === "x") {
        xDomain = Array.from(new Set(data.filter(function (d) {
          return ["number", "string"].includes(_typeof(d.x));
        }).sort(function (a, b) {
          return _this2._xSort ? _this2._xSort(a.data, b.data) : a.x - b.x;
        }).map(function (d) {
          return d.x;
        })));
        xScale = "Point";
      }

      var x2Domain = this._x2Domain ? this._x2Domain.slice() : domains.x2,
          x2Scale = this._x2Sort ? "Point" : "Linear";
      if (x2Domain && x2Domain[0] === void 0) x2Domain[0] = domains.x2[0];
      if (x2Domain && x2Domain[1] === void 0) x2Domain[1] = domains.x2[1];

      if (x2Time) {
        x2Domain = x2Domain.map(date);
        x2Scale = "Time";
      } else if (this._discrete === "x") {
        x2Domain = Array.from(new Set(data.filter(function (d) {
          return ["number", "string"].includes(_typeof(d.x2));
        }).sort(function (a, b) {
          return _this2._x2Sort ? _this2._x2Sort(a.data, b.data) : a.x2 - b.x2;
        }).map(function (d) {
          return d.x2;
        })));
        x2Scale = "Point";
      }

      var yDomain = this._yDomain ? this._yDomain.slice() : domains.y,
          yScale = this._ySort ? "Point" : "Linear";
      if (yDomain[0] === void 0) yDomain[0] = domains.y[0];
      if (yDomain[1] === void 0) yDomain[1] = domains.y[1];
      var y2Domain = this._y2Domain ? this._y2Domain.slice() : domains.y2,
          y2Scale = this._y2Sort ? "Point" : "Linear";
      if (y2Domain && y2Domain[0] === void 0) y2Domain[0] = domains.y2[0];
      if (y2Domain && y2Domain[1] === void 0) y2Domain[1] = domains.y2[1];

      if (yTime) {
        yDomain = yDomain.map(date);
        yScale = "Time";
      } else if (this._discrete === "y") {
        yDomain = Array.from(new Set(data.filter(function (d) {
          return ["number", "string"].includes(_typeof(d.y));
        }).sort(function (a, b) {
          return _this2._ySort ? _this2._ySort(a.data, b.data) : a.y - b.y;
        }).map(function (d) {
          return d.y;
        })));
        yScale = "Point";
        y2Domain = Array.from(new Set(data.filter(function (d) {
          return ["number", "string"].includes(_typeof(d.y2));
        }).sort(function (a, b) {
          return _this2._y2Sort ? _this2._y2Sort(a.data, b.data) : a.y2 - b.y2;
        }).map(function (d) {
          return d.y2;
        })));
        y2Scale = "Point";
      }

      if (y2Time) {
        y2Domain = y2Domain.map(date);
        y2Scale = "Time";
      }

      domains = {
        x: xDomain,
        x2: x2Domain || xDomain,
        y: yDomain,
        y2: y2Domain || yDomain
      };
      opps.forEach(function (opp) {
        if (_this2["_".concat(opp, "Config")].domain) {
          var _d2 = _this2["_".concat(opp, "Config")].domain;

          if (_this2._discrete === "x") _d2.reverse();
          domains[opp] = _d2;
        } else if (opp && _this2._baseline !== void 0) {
          var b = _this2._baseline;
          if (domains[opp] && domains[opp][0] > b) domains[opp][0] = b;else if (domains[opp] && domains[opp][1] < b) domains[opp][1] = b;
        }
      });

      var _x2 = scales["scale".concat(xScale)]().domain(domains.x).range(range(0, width + 1, width / (domains.x.length - 1))),
          x2 = scales["scale".concat(x2Scale)]().domain(domains.x2).range(range(0, width + 1, width / (domains.x2.length - 1))),
          _y2 = scales["scale".concat(yScale)]().domain(domains.y.reverse()).range(range(0, height + 1, height / (domains.y.length - 1))),
          y2 = scales["scale".concat(y2Scale)]().domain(domains.y2.reverse()).range(range(0, height + 1, height / (domains.y2.length - 1)));

      var shapeData = nest().key(function (d) {
        return d.shape;
      }).entries(data).sort(function (a, b) {
        return _this2._shapeSort(a.key, b.key);
      });

      var autoScale = function autoScale(axis, fallback) {
        var userScale = _this2["_".concat(axis, "Config")].scale;

        if (userScale === "auto") {
          if (_this2._discrete === axis) return fallback;
          var values = data.map(function (d) {
            return d[axis];
          });
          return deviation(values) / mean(values) > 3 ? "log" : "linear";
        }

        return userScale || fallback;
      };

      var yConfigScale = autoScale("y", yScale).toLowerCase();
      var y2ConfigScale = autoScale("y2", y2Scale).toLowerCase();
      var xConfigScale = autoScale("x", xScale).toLowerCase();
      var x2ConfigScale = autoScale("x2", x2Scale).toLowerCase();
      var oppScale = this._discrete === "x" ? yScale : xScale;

      if (oppScale !== "Point") {
        shapeData.forEach(function (d) {
          if (_this2._buffer[d.key]) {
            var res = _this2._buffer[d.key].bind(_this2)({
              data: d.values,
              x: _x2,
              y: _y2,
              yScale: yConfigScale,
              xScale: xConfigScale,
              config: _this2._shapeConfig[d.key]
            });

            _x2 = res[0];
            _y2 = res[1];

            var res2 = _this2._buffer[d.key].bind(_this2)({
              data: d.values,
              x: x2,
              y: y2,
              yScale: y2ConfigScale,
              xScale: x2ConfigScale,
              x2: true,
              y2: true,
              config: _this2._shapeConfig[d.key]
            });

            x2 = res2[0];
            y2 = res2[1];
          }
        });
      }

      xDomain = _x2.domain();
      x2Domain = x2.domain();
      yDomain = _y2.domain();
      y2Domain = y2.domain();
      var defaultConfig = {
        barConfig: {
          "stroke-width": 0
        },
        gridSize: 0,
        labels: [],
        title: false,
        tickSize: 0
      };
      var defaultX2Config = x2Exists ? {} : defaultConfig;
      var defaultY2Config = y2Exists ? {} : defaultConfig;
      var showX = this._discrete === "x" && this._width > this._discreteCutoff || this._width > this._xCutoff;
      var showY = this._discrete === "y" && this._height > this._discreteCutoff || this._height > this._yCutoff;
      var yC = {
        gridConfig: {
          stroke: !this._discrete || this._discrete === "x" ? this._yTest.gridConfig().stroke : "transparent"
        },
        locale: this._locale,
        scalePadding: _y2.padding ? _y2.padding() : 0
      };

      if (!showX) {
        yC.barConfig = {
          stroke: "transparent"
        };
        yC.tickSize = 0;
        yC.shapeConfig = {
          labelBounds: function labelBounds(d, i) {
            var _d$labelBounds = d.labelBounds,
                width = _d$labelBounds.width,
                y = _d$labelBounds.y;
            var height = _this2._height / 2;
            var x = i ? -height : 0;
            return {
              x: x,
              y: y,
              width: width,
              height: height
            };
          },
          labelConfig: {
            padding: 0,
            rotate: 0,
            verticalAlign: function verticalAlign(d) {
              return d.id === yTicks[0] ? "top" : "bottom";
            }
          },
          labelRotation: false
        };
      }

      var testGroup = elem("g.d3plus-plot-test", {
        enter: {
          opacity: 0
        },
        parent: this._select
      }),
          x2Ticks = this._discrete === "x" && !x2Time ? domains.x2 : undefined,
          xTicks = !showY ? extent(domains.x) : this._discrete === "x" && !xTime ? domains.x : undefined,
          y2Ticks = this._discrete === "y" && !y2Time ? domains.y2 : undefined,
          yTicks = !showX ? extent(domains.y) : this._discrete === "y" && !yTime ? domains.y : undefined;

      if (showY) {
        this._yTest.domain(yDomain).height(height).maxSize(width / 2).range([undefined, undefined]).select(testGroup.node()).ticks(yTicks).width(width).config(yC).config(this._yConfig).scale(yConfigScale).render();
      }

      var yBounds = this._yTest.outerBounds();

      var yWidth = yBounds.width ? yBounds.width + this._yTest.padding() : undefined;

      if (y2Exists) {
        this._y2Test.domain(y2Domain).height(height).range([undefined, undefined]).select(testGroup.node()).ticks(y2Ticks).width(width).config(yC).config(defaultY2Config).config(this._y2Config).scale(y2ConfigScale).render();
      }

      var y2Bounds = this._y2Test.outerBounds();

      var y2Width = y2Bounds.width ? y2Bounds.width + this._y2Test.padding() : undefined;
      var xC = {
        gridConfig: {
          stroke: !this._discrete || this._discrete === "y" ? this._xTest.gridConfig().stroke : "transparent"
        },
        locale: this._locale,
        scalePadding: _x2.padding ? _x2.padding() : 0
      };

      if (!showY) {
        xC.barConfig = {
          stroke: "transparent"
        };
        xC.tickSize = 0;
        xC.shapeConfig = {
          labelBounds: function labelBounds(d, i) {
            var _d$labelBounds2 = d.labelBounds,
                height = _d$labelBounds2.height,
                y = _d$labelBounds2.y;
            var width = _this2._width / 2;
            var x = i ? -width : 0;
            return {
              x: x,
              y: y,
              width: width,
              height: height
            };
          },
          labelConfig: {
            padding: 0,
            rotate: 0,
            textAnchor: function textAnchor(d) {
              return d.id === xTicks[0] ? "start" : "end";
            }
          },
          labelRotation: false
        };
      }

      var xRangeMax = undefined;

      if (this._lineLabels) {
        var lineData = nest().key(function (d) {
          return d.id;
        }).entries(data.filter(function (d) {
          return d.shape === "Line";
        }));

        if (lineData.length && lineData.length < this._dataCutoff) {
          var userConfig = configPrep.bind(this)(this._shapeConfig, "shape", "Line");
          testLineShape.config(userConfig);
          var lineLabelConfig = testLineShape.labelConfig();
          var fontSizeAccessor = lineLabelConfig.fontSize !== undefined ? lineLabelConfig.fontSize : testTextBox.fontSize();
          var fontWeightAccessor = lineLabelConfig.fontWeight !== undefined ? lineLabelConfig.fontWeight : testTextBox.fontWeight();
          var fontFamilyAccessor = lineLabelConfig.fontFamily !== undefined ? lineLabelConfig.fontFamily : testTextBox.fontFamily();
          var paddingAccessor = lineLabelConfig.padding !== undefined ? lineLabelConfig.padding : testTextBox.padding();
          var labelWidths = lineData.map(function (d) {
            var datum = d.values[0];

            var label = _this2._drawLabel(datum);

            var fontSize = typeof fontSizeAccessor === "function" ? fontSizeAccessor(datum) : fontSizeAccessor;
            var fontWeight = typeof fontWeightAccessor === "function" ? fontWeightAccessor(datum) : fontWeightAccessor;
            var fontFamily = typeof fontFamilyAccessor === "function" ? fontFamilyAccessor(datum) : fontFamilyAccessor;
            if (fontFamily instanceof Array) fontFamily = fontFamily.map(function (f) {
              return "'".concat(f, "'");
            }).join(", ");
            var labelPadding = typeof paddingAccessor === "function" ? paddingAccessor(datum) : paddingAccessor;
            var labelWidth = textWidth(label, {
              "font-size": fontSize,
              "font-family": fontFamily,
              "font-weight": fontWeight
            });
            return labelWidth + labelPadding * 2;
          });
          var largestLabel = max(labelWidths);
          var labelSpace = min([largestLabel, width / 4]);
          xRangeMax = width - labelSpace - this._margin.right;
        }
      }

      if (showX) {
        this._xTest.domain(xDomain).height(height).maxSize(height / 2).range([undefined, xRangeMax]).select(testGroup.node()).ticks(xTicks).width(width).config(xC).config(this._xConfig).scale(xConfigScale).render();
      }

      if (x2Exists) {
        this._x2Test.domain(x2Domain).height(height).range([undefined, xRangeMax]).select(testGroup.node()).ticks(x2Ticks).width(width).config(xC).tickSize(0).config(defaultX2Config).config(this._x2Config).scale(x2ConfigScale).render();
      }

      var xTestRange = this._xTest._getRange();

      var x2TestRange = this._x2Test._getRange();

      var x2Bounds = this._x2Test.outerBounds();

      var x2Height = x2Exists ? x2Bounds.height + this._x2Test.padding() : 0;
      var xOffsetLeft = max([yWidth, xTestRange[0], x2TestRange[0]]);

      if (showX) {
        this._xTest.range([xOffsetLeft, undefined]).render();
      }

      var topOffset = showY ? this._yTest.shapeConfig().labelConfig.fontSize() / 2 : 0;
      var xOffsetRight = max([y2Width, width - xTestRange[1], width - x2TestRange[1]]);

      var xBounds = this._xTest.outerBounds();

      var xHeight = xBounds.height + (showY ? this._xTest.padding() : 0);
      this._padding.left += xOffsetLeft;
      this._padding.right += xOffsetRight;
      this._padding.bottom += xHeight;
      this._padding.top += x2Height + topOffset;

      _get(_getPrototypeOf(Plot.prototype), "_draw", this).call(this, callback);

      var horizontalMargin = this._margin.left + this._margin.right;
      var verticalMargin = this._margin.top + this._margin.bottom;
      var yRange = [x2Height, height - (xHeight + topOffset + verticalMargin)];

      if (showY) {
        this._yTest.domain(yDomain).height(height).maxSize(width / 2).range(yRange).select(testGroup.node()).ticks(yTicks).width(width).config(yC).config(this._yConfig).scale(yConfigScale).render();
      }

      yBounds = this._yTest.outerBounds();
      yWidth = yBounds.width ? yBounds.width + this._yTest.padding() : undefined;
      xOffsetLeft = max([yWidth, xTestRange[0], x2TestRange[0]]);

      if (y2Exists) {
        this._y2Test.config(yC).domain(y2Domain).gridSize(0).height(height).range(yRange).select(testGroup.node()).width(width - max([0, xOffsetRight - y2Width])).title(false).config(this._y2Config).config(defaultY2Config).scale(y2ConfigScale).render();
      }

      y2Bounds = this._y2Test.outerBounds();
      y2Width = y2Bounds.width ? y2Bounds.width + this._y2Test.padding() : undefined;
      xOffsetRight = max([0, y2Width, width - xTestRange[1], width - x2TestRange[1]]);
      var xRange = [xOffsetLeft, width - (xOffsetRight + horizontalMargin)];
      var rectGroup = elem("g.d3plus-plot-background", {
        parent: parent,
        transition: transition
      });
      var transform = "translate(".concat(this._margin.left, ", ").concat(this._margin.top + x2Height + topOffset, ")");
      var x2Transform = "translate(".concat(this._margin.left, ", ").concat(this._margin.top + topOffset, ")");
      var xGroup = showX && elem("g.d3plus-plot-x-axis", {
        parent: parent,
        transition: transition,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      });
      var x2Group = x2Exists && elem("g.d3plus-plot-x2-axis", {
        parent: parent,
        transition: transition,
        enter: {
          transform: x2Transform
        },
        update: {
          transform: x2Transform
        }
      });
      var xTrans = xOffsetLeft > yWidth ? xOffsetLeft - yWidth : 0;
      var yTransform = "translate(".concat(this._margin.left + xTrans, ", ").concat(this._margin.top + topOffset, ")");
      var yGroup = showY && elem("g.d3plus-plot-y-axis", {
        parent: parent,
        transition: transition,
        enter: {
          transform: yTransform
        },
        update: {
          transform: yTransform
        }
      });
      var y2Transform = "translate(-".concat(this._margin.right, ", ").concat(this._margin.top + topOffset, ")");
      var y2Group = y2Exists && elem("g.d3plus-plot-y2-axis", {
        parent: parent,
        transition: transition,
        enter: {
          transform: y2Transform
        },
        update: {
          transform: y2Transform
        }
      });

      this._xAxis.domain(xDomain).height(height - (x2Height + topOffset + verticalMargin)).maxSize(height / 2).range(xRange).select(showX ? xGroup.node() : undefined).ticks(xTicks).width(width).config(xC).config(this._xConfig).scale(xConfigScale).render();

      if (x2Exists) {
        this._x2Axis.domain(x2Domain).height(height - (xHeight + topOffset + verticalMargin)).range(xRange).select(x2Group.node()).ticks(x2Ticks).width(width).config(xC).config(defaultX2Config).config(this._x2Config).scale(x2ConfigScale).render();
      }

      _x2 = function x(d, _x) {
        if (_x === "x2") {
          if (_this2._x2Config.scale === "log" && d === 0) d = x2Domain[0] < 0 ? -1 : 1;
          return _this2._x2Axis._getPosition.bind(_this2._x2Axis)(d);
        } else {
          if (_this2._xConfig.scale === "log" && d === 0) d = xDomain[0] < 0 ? -1 : 1;
          return _this2._xAxis._getPosition.bind(_this2._xAxis)(d);
        }
      };

      yRange = [this._xAxis.outerBounds().y + x2Height, height - (xHeight + topOffset + verticalMargin)];

      this._yAxis.domain(yDomain).height(height).maxSize(width / 2).range(yRange).select(showY ? yGroup.node() : undefined).ticks(yTicks).width(xRange[xRange.length - 1]).config(yC).config(this._yConfig).scale(yConfigScale).render();

      if (y2Exists) {
        this._y2Axis.config(yC).domain(y2Exists ? y2Domain : yDomain).gridSize(0).height(height).range(yRange).select(y2Group.node()).width(width - max([0, xOffsetRight - y2Width])).title(false).config(this._y2Config).config(defaultY2Config).scale(y2ConfigScale).render();
      }

      _y2 = function y(d, _y) {
        if (_y === "y2") {
          if (_this2._y2Config.scale === "log" && d === 0) d = y2Domain[0] < 0 ? -1 : 1;
          return _this2._y2Axis._getPosition.bind(_this2._y2Axis)(d) - x2Height;
        } else {
          if (_this2._yConfig.scale === "log" && d === 0) d = yDomain[0] < 0 ? -1 : 1;
          return _this2._yAxis._getPosition.bind(_this2._yAxis)(d) - x2Height;
        }
      };

      new shapes.Rect().data([{}]).select(rectGroup.node()).x(xRange[0] + (xRange[1] - xRange[0]) / 2).width(xRange[1] - xRange[0]).y(this._margin.top + topOffset + yRange[0] + (yRange[1] - yRange[0]) / 2).height(yRange[1] - yRange[0]).config(this._backgroundConfig).render();
      var annotationGroup = elem("g.d3plus-plot-annotations", {
        parent: parent,
        transition: transition,
        enter: {
          transform: transform
        },
        update: {
          transform: transform
        }
      }).node();

      this._annotations.forEach(function (annotation) {
        new shapes[annotation.shape]().config(annotation).config({
          x: function x(d) {
            return d.x2 ? _x2(d.x2, "x2") : _x2(d.x);
          },
          x0: _this2._discrete === "x" ? function (d) {
            return d.x2 ? _x2(d.x2, "x2") : _x2(d.x);
          } : _x2(domains.x[0]),
          x1: _this2._discrete === "x" ? null : function (d) {
            return d.x2 ? _x2(d.x2, "x2") : _x2(d.x);
          },
          y: function y(d) {
            return d.y2 ? _y2(d.y2, "y2") : _y2(d.y);
          },
          y0: _this2._discrete === "y" ? function (d) {
            return d.y2 ? _y2(d.y2, "y2") : _y2(d.y);
          } : _y2(domains.y[1]) - yOffset,
          y1: _this2._discrete === "y" ? null : function (d) {
            return d.y2 ? _y2(d.y2, "y2") : _y2(d.y) - yOffset;
          }
        }).select(annotationGroup).render();
      });

      var yOffset = this._xAxis.barConfig()["stroke-width"];

      if (yOffset) yOffset /= 2;
      var discrete = this._discrete || "x";
      var shapeConfig = {
        duration: this._duration,
        label: function label(d) {
          return _this2._drawLabel(d.data, d.i);
        },
        select: elem("g.d3plus-plot-shapes", {
          parent: parent,
          transition: transition,
          enter: {
            transform: transform
          },
          update: {
            transform: transform
          }
        }).node(),
        x: function x(d) {
          return d.x2 !== undefined ? _x2(d.x2, "x2") : _x2(d.x);
        },
        x0: discrete === "x" ? function (d) {
          return d.x2 ? _x2(d.x2, "x2") : _x2(d.x);
        } : _x2(typeof this._baseline === "number" ? this._baseline : domains.x[0]),
        x1: discrete === "x" ? null : function (d) {
          return d.x2 ? _x2(d.x2, "x2") : _x2(d.x);
        },
        y: function y(d) {
          return d.y2 !== undefined ? _y2(d.y2, "y2") : _y2(d.y);
        },
        y0: discrete === "y" ? function (d) {
          return d.y2 ? _y2(d.y2, "y2") : _y2(d.y);
        } : _y2(typeof this._baseline === "number" ? this._baseline : domains.y[1]) - yOffset,
        y1: discrete === "y" ? null : function (d) {
          return d.y2 ? _y2(d.y2, "y2") : _y2(d.y) - yOffset;
        }
      };

      if (this._stacked) {
        var scale = opp === "x" ? _x2 : _y2;

        shapeConfig["".concat(opp)] = shapeConfig["".concat(opp, "0")] = function (d) {
          var dataIndex = stackKeys.indexOf(d.id),
              discreteIndex = discreteKeys.indexOf(d.discrete);
          return dataIndex >= 0 ? scale(stackData[dataIndex][discreteIndex][0]) : scale(domains[opp][opp === "x" ? 0 : 1]);
        };

        shapeConfig["".concat(opp, "1")] = function (d) {
          var dataIndex = stackKeys.indexOf(d.id),
              discreteIndex = discreteKeys.indexOf(d.discrete);
          return dataIndex >= 0 ? scale(stackData[dataIndex][discreteIndex][1]) : scale(domains[opp][opp === "x" ? 0 : 1]);
        };
      }

      var events = Object.keys(this._on);
      shapeData.forEach(function (d) {
        var s = new shapes[d.key]().config(shapeConfig).data(d.values);

        if (d.key === "Bar") {
          var space;

          var _scale = _this2._discrete === "x" ? _x2 : _y2;

          var scaleType = _this2._discrete === "x" ? xScale : yScale;
          var vals = _this2._discrete === "x" ? xDomain : yDomain;

          var _range = _this2._discrete === "x" ? xRange : yRange;

          if (scaleType !== "Point" && vals.length === 2) {
            space = (_scale(d.values[_this2._discrete === "x" ? 0 : d.values.length - 1][_this2._discrete]) - _scale(vals[0])) * 2;
          } else if (vals.length > 1) space = _scale(vals[1]) - _scale(vals[0]);else space = _range[_range.length - 1] - _range[0];

          if (_this2._groupPadding < space) space -= _this2._groupPadding;
          var barSize = space || 1;
          var groups = nest().key(function (d) {
            return d[_this2._discrete];
          }).key(function (d) {
            return d.group;
          }).entries(d.values);
          var ids = merge(groups.map(function (d) {
            return d.values.map(function (v) {
              return v.key;
            });
          }));
          var uniqueIds = Array.from(new Set(ids));

          if (max(groups.map(function (d) {
            return d.values.length;
          })) === 1) {
            s[_this2._discrete](function (d, i) {
              return shapeConfig[_this2._discrete](d, i);
            });
          } else {
            barSize = (barSize - _this2._barPadding * uniqueIds.length - 1) / uniqueIds.length;
            var offset = space / 2 - barSize / 2;
            var xMod = scales.scaleLinear().domain([0, uniqueIds.length - 1]).range([-offset, offset]);

            s[_this2._discrete](function (d, i) {
              return shapeConfig[_this2._discrete](d, i) + xMod(uniqueIds.indexOf(d.group));
            });
          }

          s.width(barSize);
          s.height(barSize);
        } else if (d.key === "Line") {
          s.duration(width * 1.5);

          if (_this2._confidence) {
            var areaConfig = Object.assign({}, shapeConfig);

            var _discrete2 = _this2._discrete || "x";

            var key = _discrete2 === "x" ? "y" : "x";
            var scaleFunction = _discrete2 === "x" ? _y2 : _x2;

            areaConfig["".concat(key, "0")] = function (d) {
              return scaleFunction(_this2._confidence[0] ? d.lci : d[key]);
            };

            areaConfig["".concat(key, "1")] = function (d) {
              return scaleFunction(_this2._confidence[1] ? d.hci : d[key]);
            };

            var area = new shapes.Area().config(areaConfig).data(d.values);
            var confidenceConfig = Object.assign(_this2._shapeConfig, _this2._confidenceConfig);
            area.config(configPrep.bind(_this2)(confidenceConfig, "shape", "Area")).render();

            _this2._shapes.push(area);
          }

          s.config({
            label: _this2._lineLabels ? _this2._drawLabel : false,
            labelBounds: _this2._lineLabels ? function (d, i, s) {
              var _s$points$ = _slicedToArray(s.points[0], 2),
                  firstX = _s$points$[0],
                  firstY = _s$points$[1];

              var _s$points = _slicedToArray(s.points[s.points.length - 1], 2),
                  lastX = _s$points[0],
                  lastY = _s$points[1];

              var height = _this2._height / 4;
              return {
                x: lastX - firstX,
                y: lastY - firstY - height / 2,
                width: _this2._padding.right,
                height: height
              };
            } : false
          });
        }

        var classEvents = events.filter(function (e) {
          return e.includes(".".concat(d.key));
        }),
            globalEvents = events.filter(function (e) {
          return !e.includes(".");
        }),
            shapeEvents = events.filter(function (e) {
          return e.includes(".shape");
        });

        var _loop = function _loop(e) {
          s.on(globalEvents[e], function (d) {
            return _this2._on[globalEvents[e]](d.data, d.i);
          });
        };

        for (var e = 0; e < globalEvents.length; e++) {
          _loop(e);
        }

        var _loop2 = function _loop2(_e2) {
          s.on(shapeEvents[_e2], function (d) {
            return _this2._on[shapeEvents[_e2]](d.data, d.i);
          });
        };

        for (var _e2 = 0; _e2 < shapeEvents.length; _e2++) {
          _loop2(_e2);
        }

        var _loop3 = function _loop3(_e3) {
          s.on(classEvents[_e3], function (d) {
            return _this2._on[classEvents[_e3]](d.data, d.i);
          });
        };

        for (var _e3 = 0; _e3 < classEvents.length; _e3++) {
          _loop3(_e3);
        }

        var userConfig = configPrep.bind(_this2)(_this2._shapeConfig, "shape", d.key);
        if (_this2._shapeConfig.duration === undefined) delete userConfig.duration;
        s.config(userConfig).render();

        _this2._shapes.push(s);

        if (d.key === "Line" && _this2._lineMarkers) {
          var markers = new shapes.Circle().data(d.values).config(shapeConfig).config(_this2._lineMarkerConfig).id(function (d) {
            return "".concat(d.id, "_").concat(d.discrete);
          });

          var _loop4 = function _loop4(_e4) {
            markers.on(globalEvents[_e4], function (d) {
              return _this2._on[globalEvents[_e4]](d.data, d.i);
            });
          };

          for (var _e4 = 0; _e4 < globalEvents.length; _e4++) {
            _loop4(_e4);
          }

          var _loop5 = function _loop5(_e5) {
            markers.on(shapeEvents[_e5], function (d) {
              return _this2._on[shapeEvents[_e5]](d.data, d.i);
            });
          };

          for (var _e5 = 0; _e5 < shapeEvents.length; _e5++) {
            _loop5(_e5);
          }

          var _loop6 = function _loop6(_e6) {
            markers.on(classEvents[_e6], function (d) {
              return _this2._on[classEvents[_e6]](d.data, d.i);
            });
          };

          for (var _e6 = 0; _e6 < classEvents.length; _e6++) {
            _loop6(_e6);
          }

          markers.render();

          _this2._shapes.push(markers);
        }
      });
      var dataShapes = shapeData.map(function (d) {
        return d.key;
      });

      if (dataShapes.includes("Line")) {
        if (this._confidence) dataShapes.push("Area");
        if (this._labelMarkers) dataShapes.push("Circle");
      }

      var exitShapes = this._previousShapes.filter(function (d) {
        return !dataShapes.includes(d);
      });

      exitShapes.forEach(function (shape) {
        new shapes[shape]().config(shapeConfig).data([]).render();
      });
      this._previousShapes = dataShapes;
      return this;
    }
    /**
        @memberof Plot
        @desc Allows drawing custom shapes to be used as annotations in the provided x/y plot. This method accepts custom config objects for the [Shape](http://d3plus.org/docs/#Shape) class, either a single config object or an array of config objects. Each config object requires an additional parameter, the "shape", which denotes which [Shape](http://d3plus.org/docs/#Shape) sub-class to use ([Rect](http://d3plus.org/docs/#Rect), [Line](http://d3plus.org/docs/#Line), etc). Annotations will be drawn underneath the data to be displayed.
        @param {Array|Object} *annotations* = []
        @chainable
    */

  }, {
    key: "annotations",
    value: function annotations(_) {
      return arguments.length ? (this._annotations = _ instanceof Array ? _ : [_], this) : this._annotations;
    }
    /**
         @memberof Plot
         @desc A d3plus-shape configuration Object used for styling the background rectangle of the inner x/y plot (behind all of the shapes and gridlines).
         @param {Object} [*value*]
         @chainable
     */

  }, {
    key: "backgroundConfig",
    value: function backgroundConfig(_) {
      return arguments.length ? (this._backgroundConfig = assign(this._backgroundConfig, _), this) : this._backgroundConfig;
    }
    /**
        @memberof Plot
        @desc Sets the pixel space between each bar in a group of bars.
        @param {Number} *value* = 0
        @chainable
    */

  }, {
    key: "barPadding",
    value: function barPadding(_) {
      return arguments.length ? (this._barPadding = _, this) : this._barPadding;
    }
    /**
        @memberof Plot
        @desc Sets the baseline for the x/y plot. If *value* is not specified, returns the current baseline.
        @param {Number} *value*
        @chainable
    */

  }, {
    key: "baseline",
    value: function baseline(_) {
      return arguments.length ? (this._baseline = _, this) : this._baseline;
    }
    /**
         @memberof Plot
         @desc Sets the confidence to the specified array of lower and upper bounds.
         @param {String[]|Function[]} *value*
         @chainable
         @example <caption>Can be called with accessor functions or static keys:</caption>
         var data = {id: "alpha", value: 10, lci: 9, hci: 11};
         ...
         // Accessor functions
         .confidence([function(d) { return d.lci }, function(d) { return d.hci }])
          // Or static keys
         .confidence(["lci", "hci"])
     */

  }, {
    key: "confidence",
    value: function confidence(_) {
      if (arguments.length && _ instanceof Array) {
        this._confidence = [];
        var lower = _[0];
        this._confidence[0] = typeof lower === "function" || !lower ? lower : accessor(lower);
        var upper = _[1];
        this._confidence[1] = typeof upper === "function" || !upper ? upper : accessor(upper);
        return this;
      } else return this._confidence;
    }
    /**
         @memberof Plot
         @desc If *value* is specified, sets the config method for each shape rendered as a confidence interval and returns the current class instance.
         @param {Object} [*value*]
         @chainable
     */

  }, {
    key: "confidenceConfig",
    value: function confidenceConfig(_) {
      return arguments.length ? (this._confidenceConfig = assign(this._confidenceConfig, _), this) : this._confidenceConfig;
    }
    /**
        @memberof Plot
        @desc Sets the discrete axis to the specified string. If *value* is not specified, returns the current discrete axis.
        @param {String} *value*
        @chainable
    */

  }, {
    key: "discrete",
    value: function discrete(_) {
      return arguments.length ? (this._discrete = _, this) : this._discrete;
    }
    /**
        @memberof Plot
        @desc When the width or height of the chart is less than or equal to this pixel value, the discrete axis will not be shown. This helps produce slick sparklines. Set this value to `0` to disable the behavior entirely.
        @param {Number} *value*
        @chainable
    */

  }, {
    key: "discreteCutoff",
    value: function discreteCutoff(_) {
      return arguments.length ? (this._discreteCutoff = _, this) : this._discreteCutoff;
    }
    /**
        @memberof Plot
        @desc Sets the pixel space between groups of bars.
        @param {Number} [*value* = 5]
        @chainable
    */

  }, {
    key: "groupPadding",
    value: function groupPadding(_) {
      return arguments.length ? (this._groupPadding = _, this) : this._groupPadding;
    }
    /**
        @memberof Plot
        @desc Draws labels on the right side of any Line shapes that are drawn on the plot.
        @param {Boolean} [*value* = false]
        @chainable
    */

  }, {
    key: "lineLabels",
    value: function lineLabels(_) {
      return arguments.length ? (this._lineLabels = _, this) : this._lineLabels;
    }
    /**
        @memberof Plot
        @desc Shape config for the Circle shapes drawn by the lineMarkers method.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "lineMarkerConfig",
    value: function lineMarkerConfig(_) {
      return arguments.length ? (this._lineMarkerConfig = assign(this._lineMarkerConfig, _), this) : this._lineMarkerConfig;
    }
    /**
        @memberof Plot
        @desc Draws circle markers on each vertex of a Line.
        @param {Boolean} [*value* = false]
        @chainable
    */

  }, {
    key: "lineMarkers",
    value: function lineMarkers(_) {
      return arguments.length ? (this._lineMarkers = _, this) : this._lineMarkers;
    }
    /**
        @memberof Plot
        @desc A JavaScript [sort comparator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) that receives each shape Class (ie. "Circle", "Line", etc) as it's comparator arguments. Shapes are drawn in groups based on their type, so you are defining the layering order for all shapes of said type.
        @param {Function} *value*
        @chainable
    */

  }, {
    key: "shapeSort",
    value: function shapeSort(_) {
      return arguments.length ? (this._shapeSort = _, this) : this._shapeSort;
    }
    /**
        @memberof Plot
        @desc Sets the size of bubbles to the given Number, data key, or function.
        @param {Function|Number|String} *value* = 10
        @chainable
    */

  }, {
    key: "size",
    value: function size(_) {
      return arguments.length ? (this._size = typeof _ === "function" || !_ ? _ : accessor(_), this) : this._size;
    }
    /**
        @memberof Plot
        @desc Sets the size scale maximum to the specified number.
        @param {Number} *value* = 20
        @chainable
    */

  }, {
    key: "sizeMax",
    value: function sizeMax(_) {
      return arguments.length ? (this._sizeMax = _, this) : this._sizeMax;
    }
    /**
        @memberof Plot
        @desc Sets the size scale minimum to the specified number.
        @param {Number} *value* = 5
        @chainable
    */

  }, {
    key: "sizeMin",
    value: function sizeMin(_) {
      return arguments.length ? (this._sizeMin = _, this) : this._sizeMin;
    }
    /**
        @memberof Plot
        @desc Sets the size scale to the specified string.
        @param {String} *value* = "sqrt"
        @chainable
    */

  }, {
    key: "sizeScale",
    value: function sizeScale(_) {
      return arguments.length ? (this._sizeScale = _, this) : this._sizeScale;
    }
    /**
        @memberof Plot
        @desc If *value* is specified, toggles shape stacking. If *value* is not specified, returns the current stack value.
        @param {Boolean} *value* = false
        @chainable
    */

  }, {
    key: "stacked",
    value: function stacked(_) {
      return arguments.length ? (this._stacked = _, this) : this._stacked;
    }
    /**
        @memberof Plot
        @desc Sets the stack offset. If *value* is not specified, returns the current stack offset function.
        @param {Function|String} *value* = "descending"
        @chainable
    */

  }, {
    key: "stackOffset",
    value: function stackOffset(_) {
      return arguments.length ? (this._stackOffset = typeof _ === "function" ? _ : d3Shape["stackOffset".concat(_.charAt(0).toUpperCase() + _.slice(1))], this) : this._stackOffset;
    }
    /**
        @memberof Plot
        @desc Sets the stack order. If *value* is not specified, returns the current stack order function.
        @param {Function|String|Array} *value* = "none"
        @chainable
    */

  }, {
    key: "stackOrder",
    value: function stackOrder(_) {
      if (arguments.length) {
        if (typeof _ === "string") this._stackOrder = _ === "ascending" ? stackOrderAscending : _ === "descending" ? stackOrderDescending : d3Shape["stackOrder".concat(_.charAt(0).toUpperCase() + _.slice(1))];else this._stackOrder = _;
        return this;
      } else return this._stackOrder;
    }
    /**
        @memberof Plot
        @desc Sets the x accessor to the specified function or number. If *value* is not specified, returns the current x accessor.
        @param {Function|Number} *value*
        @chainable
    */

  }, {
    key: "x",
    value: function x(_) {
      if (arguments.length) {
        if (typeof _ === "function") this._x = _;else {
          this._x = accessor(_);

          if (!this._aggs[_] && this._discrete === "x") {
            this._aggs[_] = function (a) {
              var v = Array.from(new Set(a));
              return v.length === 1 ? v[0] : v;
            };
          }
        }
        return this;
      } else return this._x;
    }
    /**
         @memberof Plot
         @desc Sets the x2 accessor to the specified function or number. If *value* is not specified, returns the current x2 accessor.
         @param {Function|Number} *value*
         @chainable
     */

  }, {
    key: "x2",
    value: function x2(_) {
      if (arguments.length) {
        if (typeof _ === "function") this._x2 = _;else {
          this._x2 = accessor(_);

          if (!this._aggs[_] && this._discrete === "x") {
            this._aggs[_] = function (a) {
              var v = Array.from(new Set(a));
              return v.length === 1 ? v[0] : v;
            };
          }
        }
        return this;
      } else return this._x2;
    }
    /**
        @memberof Plot
        @desc A pass-through to the underlying [Axis](http://d3plus.org/docs/#Axis) config used for the x-axis. Includes additional functionality where passing "auto" as the value for the [scale](http://d3plus.org/docs/#Axis.scale) method will determine if the scale should be "linear" or "log" based on the provided data.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "xConfig",
    value: function xConfig(_) {
      return arguments.length ? (this._xConfig = assign(this._xConfig, _), this) : this._xConfig;
    }
    /**
        @memberof Plot
        @desc When the width of the chart is less than or equal to this pixel value, and the x-axis is not the discrete axis, it will not be shown. This helps produce slick sparklines. Set this value to `0` to disable the behavior entirely.
        @param {Number} *value*
        @chainable
    */

  }, {
    key: "xCutoff",
    value: function xCutoff(_) {
      return arguments.length ? (this._xCutoff = _, this) : this._xCutoff;
    }
    /**
        @memberof Plot
        @desc A pass-through to the underlying [Axis](http://d3plus.org/docs/#Axis) config used for the secondary x-axis. Includes additional functionality where passing "auto" as the value for the [scale](http://d3plus.org/docs/#Axis.scale) method will determine if the scale should be "linear" or "log" based on the provided data.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "x2Config",
    value: function x2Config(_) {
      return arguments.length ? (this._x2Config = assign(this._x2Config, _), this) : this._x2Config;
    }
    /**
        @memberof Plot
        @desc Sets the x domain to the specified array. If *value* is not specified, returns the current x domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
        @param {Array} *value*
        @chainable
    */

  }, {
    key: "xDomain",
    value: function xDomain(_) {
      return arguments.length ? (this._xDomain = _, this) : this._xDomain;
    }
    /**
         @memberof Plot
         @desc Sets the x2 domain to the specified array. If *value* is not specified, returns the current x2 domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
         @param {Array} *value*
         @chainable
     */

  }, {
    key: "x2Domain",
    value: function x2Domain(_) {
      return arguments.length ? (this._x2Domain = _, this) : this._x2Domain;
    }
    /**
        @memberof Plot
        @desc Defines a custom sorting comparitor function to be used for discrete x axes.
        @param {Function} *value*
        @chainable
    */

  }, {
    key: "xSort",
    value: function xSort(_) {
      return arguments.length ? (this._xSort = _, this) : this._xSort;
    }
    /**
         @memberof Plot
         @desc Defines a custom sorting comparitor function to be used for discrete x2 axes.
         @param {Function} *value*
         @chainable
     */

  }, {
    key: "x2Sort",
    value: function x2Sort(_) {
      return arguments.length ? (this._x2Sort = _, this) : this._x2Sort;
    }
    /**
        @memberof Plot
        @desc Sets the y accessor to the specified function or number. If *value* is not specified, returns the current y accessor.
        @param {Function|Number} *value*
        @chainable
    */

  }, {
    key: "y",
    value: function y(_) {
      if (arguments.length) {
        if (typeof _ === "function") this._y = _;else {
          this._y = accessor(_);

          if (!this._aggs[_] && this._discrete === "y") {
            this._aggs[_] = function (a) {
              var v = Array.from(new Set(a));
              return v.length === 1 ? v[0] : v;
            };
          }
        }
        return this;
      } else return this._y;
    }
    /**
         @memberof Plot
         @desc Sets the y2 accessor to the specified function or number. If *value* is not specified, returns the current y2 accessor.
         @param {Function|Number} *value*
         @chainable
     */

  }, {
    key: "y2",
    value: function y2(_) {
      if (arguments.length) {
        if (typeof _ === "function") this._y2 = _;else {
          this._y2 = accessor(_);

          if (!this._aggs[_] && this._discrete === "y2") {
            this._aggs[_] = function (a) {
              var v = Array.from(new Set(a));
              return v.length === 1 ? v[0] : v;
            };
          }
        }
        return this;
      } else return this._y2;
    }
    /**
        @memberof Plot
        @desc A pass-through to the underlying [Axis](http://d3plus.org/docs/#Axis) config used for the y-axis. Includes additional functionality where passing "auto" as the value for the [scale](http://d3plus.org/docs/#Axis.scale) method will determine if the scale should be "linear" or "log" based on the provided data.
    *Note:* If a "domain" array is passed to the y-axis config, it will be reversed.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "yConfig",
    value: function yConfig(_) {
      if (arguments.length) {
        if (_.domain) _.domain = _.domain.slice().reverse();
        this._yConfig = assign(this._yConfig, _);
        return this;
      }

      return this._yConfig;
    }
    /**
        @memberof Plot
        @desc When the height of the chart is less than or equal to this pixel value, and the y-axis is not the discrete axis, it will not be shown. This helps produce slick sparklines. Set this value to `0` to disable the behavior entirely.
        @param {Number} *value*
        @chainable
    */

  }, {
    key: "yCutoff",
    value: function yCutoff(_) {
      return arguments.length ? (this._yCutoff = _, this) : this._yCutoff;
    }
    /**
        @memberof Plot
        @desc A pass-through to the underlying [Axis](http://d3plus.org/docs/#Axis) config used for the secondary y-axis. Includes additional functionality where passing "auto" as the value for the [scale](http://d3plus.org/docs/#Axis.scale) method will determine if the scale should be "linear" or "log" based on the provided data.
        @param {Object} *value*
        @chainable
    */

  }, {
    key: "y2Config",
    value: function y2Config(_) {
      if (arguments.length) {
        if (_.domain) _.domain = _.domain.slice().reverse();
        this._y2Config = assign(this._y2Config, _);
        return this;
      }

      return this._y2Config;
    }
    /**
        @memberof Plot
        @desc Sets the y domain to the specified array. If *value* is not specified, returns the current y domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
        @param {Array} *value*
        @chainable
    */

  }, {
    key: "yDomain",
    value: function yDomain(_) {
      return arguments.length ? (this._yDomain = _, this) : this._yDomain;
    }
    /**
         @memberof Plot
         @desc Sets the y2 domain to the specified array. If *value* is not specified, returns the current y2 domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
         @param {Array} *value*
         @chainable
     */

  }, {
    key: "y2Domain",
    value: function y2Domain(_) {
      return arguments.length ? (this._y2Domain = _, this) : this._y2Domain;
    }
    /**
        @memberof Plot
        @desc Defines a custom sorting comparitor function to be used for discrete y axes.
        @param {Function} *value*
        @chainable
    */

  }, {
    key: "ySort",
    value: function ySort(_) {
      return arguments.length ? (this._ySort = _, this) : this._ySort;
    }
    /**
         @memberof Plot
         @desc Defines a custom sorting comparitor function to be used for discrete y2 axes.
         @param {Function} *value*
         @chainable
     */

  }, {
    key: "y2Sort",
    value: function y2Sort(_) {
      return arguments.length ? (this._y2Sort = _, this) : this._y2Sort;
    }
  }]);

  return Plot;
}(Viz);

export { Plot as default };